\section{Process API}

\textbf{Execution Model -- Assembler (simplified)}
\begin{items}
  \item OS interacts directly with compiled programs \\*
    - switch between processes/threads \( \leadsto \) \textbf{save}/\textbf{restore} state \\*
    - deal with/pass on \textbf{signals}/\textbf{exceptions} \\*
    - receive \textbf{requests} from applications
  \item \underline{Instructions}: \\*
    - \code{mov}: Copy referenced data from second operand to first operand \\*
    - \code{add}/\code{sub}/\code{mul}/\code{div}: Add,\dots from second operand to first operand \\*
    - \code{inc}/\code{dec}: increment/decrement register/memory location \\*
    - \code{shl}/\code{shr}: shift first operand left/right by amount given by second operand \\*
    - \code{and}/\code{or}/\code{xor}: calculate bitwise and,\dots of two operands storing result in first \\*
    - \code{not}: bitwise negate operand
\end{items}

\ \\
\textbf{Execution Model -- Stack (x86)}
\begin{items}
  \item \underline{stack pointer} (SP): holds address of stack top (growing downwards)
  \item \underline{stack frames}: larger stack chunks
  \item \underline{base pointer} (BP): used to organize stack frames
\end{items}

\ \\
\textbf{Execution Model -- jump/branch/call commands (x86)}
\begin{items}
  \item \code{jmp}: continue execution at operand address
  \item \code{j\$condition}: jump depending on PSW content \\*
    true \( \leadsto \) jump \\*
    false \( \leadsto \) continue \\*
    examples: \code{je} (jump equal), \code{jz} (jump zero)
  \item \code{call}: push function to stack and jump to it
  \item \code{return}: return from function (jump to return address)
\end{items}

\ \\
\textbf{Execution Model -- Application Binary Interface (ABI)}
\begin{items}
  \item standardizes binary interface between programs, modules, OS: \\*
    - executable/object file layout \\*
    - calling conventions \\*
    - alignment rules
  \item \underline{calling conventions}: standardize exact way function calls are implemented \\*
    \( \leadsto \) interoperability between compilers
\end{items}

\textbf{Execution Model -- calling conventions (x86)}
\begin{items}
  \item function call (caller):
  \begin{enumeration}
    \item save local scope state 
    \item set up parameters where function can find them
    \item transfer control flow
  \end{enumeration}
  \item function call (called function):
  \begin{enumeration}
    \item set up new local scope (local variables)
    \item perform duty
    \item put return value where caller can find it
    \item jump back to caller (IP)
  \end{enumeration}
\end{items}

\textbf{Passing parameters to the system}
\begin{items}
  \item parameters are passed through \textbf{system calls}
  \item call number + specific parameters must be passed
  \item parameters can be transferred through \\*
    - \underline{CPU registers} (\textasciitilde 6) \\*
    - \underline{Main Memory} (heap/stack -- more parameters, data types)
  \item ABI specifies how to pass parameters
  \item \underline{return code} needs to be returned to application \\*
    - \textbf{negative}: error code \\*
    - \textbf{positive + 0}: success \\*
    - usually returned via A+D registers
\end{items}

\textbf{System call handler}
\begin{items}
  \item implements the actual serivce called through a syscall:
  \begin{enumeration}
    \item saves tainted registers
    \item reads passed parameters
    \item sanitizes/checks parameters
    \item checks if caller has enough permissions to perform the requested action
    \item performs requested action in behalf of the caller
    \item returns to caller with success/error code
  \end{enumeration}
\end{items}