\section{Intro to C}

\textbf{Hello World}
\lstinputlisting[style=customc]{hello.c}
\begin{items}
  \item \code{#include}: preprocessor inserts \code{stdio.h} contents
  \item \code{stdio.h}: contains \code{printf} declaration
  \item \code{main}: program starts here
  \item \code{void}: keyword for argument absence
  \item \code{\{  \}}: basic block/scope delimiters
  \item \code{printf}: prints to the terminal
  \item \code{\\n}: newline character
  \item \code{return}: leave function, return value
\end{items}

\textbf{Compiling}
\begin{lstlisting}[style=custombash]
  $ gcc hello.c -o hello
  $ ./hello
  Hello World!
\end{lstlisting}

\textbf{Basic Data Types}
\begin{items}
  \item \code{char c = 5; char c = 'a';} \\*
    one byte, usually for characters (1970: ASCII is fine)
  \item \code{int i = 5; int i = 0xf; int i = 'a';} \\*
    usually 4 bytes, holds integers
  \item \code{float f = 5; float f = 5.5;} \\*
    4 bytes floating point number
  \item \code{double d = 5.19562} \\*
    8 bytes double precision floating point number
\end{items}

\textbf{Basic Data Types -- logic}
\begin{items}
  \item \code{int i = 5 / 2; // i = 2} \\*
    integer logic, no rounding
  \item \code{float f = 5.0f / 2; // f = 2.5f} \\*
    decimal logic for float and double
  \item \code{char a = 'a' / 2 // a = 97 / 2 = 48} \\*
    \code{char} interpreted as character by console
\end{items}

\textbf{Basic Data Types -- signed/unsigned}
\begin{items}
  \item \code{signed int i = -5 // i = -5} (two's complement)
  \item \code{unsigned int i = -5 // i = 4294967291}
\end{items}

\textbf{Basic Data Types -- short/long}
\begin{items}
  \item \code{short int i = 1024 // -32768...32767}
  \item \code{long int i = 1024 // -2147483648...2147483647}
\end{items}

\textbf{Basic Data Types -- more size stuff}
\begin{items}
  \item \code{sizeof int; sizeof long int; // 4; 4;} (x86 32-Bit)
  \item use data types from \code{inttypes.h} to be sure about sizes:
  \begin{lstlisting}[style=customc]
#include <inttypes.h>
int8_t i; uint32_t j;
  \end{lstlisting}
\end{items}

\textbf{Basic Data Types -- const/volatile}
\begin{items}
  \item \code{const int c = 5;} \\*
    \code{i} is constant, changing it will raise compiler error
  \item \code{volatile int i = 5;} \\*
    \code{i} is volatile, may be modified elsewhere (by different program in shared memory, important for CPU caches, register, assumptions thereof)
\end{items}

\newpage

\textbf{Variables -- local vs. global}
\begin{lstlisting}[style=customc]
int m; // global variable

int myroutine(int j) {
  int i = 5 // local variable
  i = i+j;
  return i;
}
\end{lstlisting}
\begin{items}
  \item \emph{global variables} (\code{int m}): \\*
    lifetime: while program runs \\*
    placed on pre-defined place in memory
  \item basic block/function-local variables (\code{int i}): \\*
    lifetime: during invocation of routine \\*
    placed on stack or in registers
\end{items}

\textbf{Variables -- local vs. static}
\begin{lstlisting}[style=customc]
int myroutine(int j) {
  static int i = 5;
  i = i+j;
  return i;
}

k = myroutine(1); // k = 6
k = myroutine(1); // k = 7
\end{lstlisting}
\begin{items}
  \item static function-local variables: \\*
    saved like global variables \\*
    variable persistent across invocations \\*
    lifetime: like global variables
\end{items}

\textbf{Printing}
\begin{lstlisting}[style=customc]
int i = 5; float f = 2.5;
printf("The numbers are i=%d, f=%f", i, f);
\end{lstlisting}
\begin{items}
  \item comprised of format string and arguments
  \item may contain format identifiers (\code{\%d})
  \item see also \code{man printf}
  \item \underline{special characters}: encoded via leading backslash: \\*
    \code{\\n} newline \\*
    \code{\\t} tab \\*
    \code{\\'} single quote \\*
    \code{\\"} double quote \\*
    \code{\\0} \code{null}, end of string
\end{items}

\textbf{Compound data types}
\begin{items}
  \item \code{struct}ure: collection of named variables (different types)
  \item \code{union}: \emph{single} variable that can have multiple types
  \item members accessed via \code{.} operator
\end{items}
\begin{lstlisting}[style=customc]
struct coordinate {
  int x;
  int y;
}

union longorfloat {
  long l;
  float f;
}

struct coordinate c;
c.x = 5;
c.y = 6;

union longorfloat lf;
lf.l = 5;
lf.f = 6.192;
\end{lstlisting}

\newpage

\textbf{Functions}
\begin{items}
  \item encapsulate functionality (\emph{reuse})
  \item code structuring (\emph{reduce complexity})
  \item must be \textbf{declared} and \textbf{defined}
  \item \underline{Declaration}: states signature
  \item \underline{Definition}: states implementation (implicitly declares function)
\end{items}
\begin{lstlisting}[style=customc]
int sum(int a, int b); // declaration

int sum(int a, int b) { // definition
  return a+b;
}
\end{lstlisting}

\textbf{Header files}
\begin{items}
  \item header file for frequently used declarations
  \item use \code{extern} to declare global variables defined elsewhere
  \item use \code{static} to limit scope to current file (e.g. \code{static float pi} in \code{sum.c}: no \code{pi} in \code{main.c})
  \begin{lstlisting}[style=customc]
// mymath.h
int sum(int a, int b);
extern float pi;

// sum.c
#include "mymath.h"

float pi = 3.1415927;
int sum(int a, int b) {
  return a+b;
}

// main.c
#include <stdio.h>
#include "mymath.h"

void main() {
  printf("%d\n", sum(1,2));
  printf("%f\n", pi);
}
  \end{lstlisting}
\end{items}

\textbf{Data Segments and Variables}
\begin{items}
  \item \underline{Stack}: local variables
  \item \underline{Heap}: variables crated at runtime via \code{malloc()}/\code{free()}
  \item \underline{Data Segment}: static/global variables
  \item \underline{Code}: functions
\end{items}

\textbf{Function overloading}
\begin{items}
  \item \emph{no function overloading in C!}
  \item use arrays ore pointers
\end{items}

\textbf{Pointers}
\begin{lstlisting}[style=customc]
int a = 5;
int *p = &a // points to int, initalized to point to a
int *q = 32 // points to int at address 32
int b = a+1;
int c = *p; // dereference(p) = dereference(&a) = 5
int d = (*p)+2 // = 7
int *r = p+1; // pointing to next element p is pointing to
int e = *(p+2) // dereference (p+2) = d = 7
\end{lstlisting}

\textbf{Pointers -- linked list}
\begin{items}
  \item linked-list implementation via next-pointer
\end{items}
\begin{lstlisting}[style=customc]
struct ll {
  int item;
  struct ll *next;
}

struct l first;
first.item = 123;

struct ll second;
second.item = 456;
first.next = &second;
\end{lstlisting}

\newpage

\textbf{Arrays}
\begin{items}
  \item = fixed number of variables \emph{continuously laid out in memory}
\end{items}
\begin{lstlisting}[style=customc]
int A[5]; // declare array (reserve memory space)
A[4] = 25; A[0] = 24; // assign 25 to last, 24 to first elem
char c[] = {'a',5,6,7,'B'} // init array, length implicit
c[64] = 'Z' // NO bounds checking at compile/run (may raise protection fault)

// declare pointer to array; address elements via pointer:
char *p = c;
*(p+1) = 'Z'; p[3] = 'B'; char b = *p; // = 'a'
\end{lstlisting}

\textbf{Strings}
\begin{items}
  \item = array of \code{char}s terminated by \code{NULL}:
  \begin{lstlisting}[style=customc]
char A[] = { 'T', 'e', 's', 't', '\0' };
char A[] = "Test";
  \end{lstlisting}
  \item declaration via pointer: \\*
    \code{const char *p = "Test";}
  \item common string functions (\code{string.h}): \\*
    length: \code{size_t strnlen(const char *s, size_t maxlen)} \\*
    compare: \\* \phantom{x} \code{int strncmp(const char *s1, const char *s2, size_t n);} \\*
    copy: \code{int strncpy(char *dest, const char *src size_t n);} \\*
    tokenize: \code{char *strtok(char *str, const char *delim);} \\* \phantom{x} (e.g. split line into words)
\end{items}